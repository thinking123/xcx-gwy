<template>
  <view class="CListWrap external-cls"
        style="display: {{show ? 'block' : 'none'}}"
  >

    <view class="CListWrap-header">
      <slot name="header"/>
    </view>
    <view class="CListWrap-wrap">

      <slot/>
      <view wx:if="{{curItems.length == 0 && loaded}}" class="noData">
         没有数据
      </view>
    </view>
    <view class="CListWrap-loading">

    </view>
    <view class="CListWrap-dst">
      <view wx:if="{{isLoading}}">
        <CLoading type="spinner"/>
      </view>
      <view wx:if="{{isEnd && curItems.length > 0}}">
        没有更多了
      </view>
      <view wx:if="{{isError}}">
        {{errorMsg || '加载失败'}}
      </view>
    </view>

  </view>

</template>
<script>
  import wepy from '@wepy/core';
  import store from 'store';
  import { mapMutations, mapGetters } from '@wepy/x';
  import { get } from '@/http/http';
  import { showMsg, urlParams } from '@/common/utils';

  const defFun = () => {
    console.log('defFun')
  }
  wepy.component({
    store,
    data: {
      isEnd: false,
      isLoading: false,
      pageNum: 0,
      pages: 0,
      total: 0,
      isError: false,
      errorMsg: '',
      other: {},
      mockPage: 1,
      mockPages: 5,
      mockTotal: 200,
      curItems:[],
      loaded:false
    },
    externalClasses: [
      'external-cls'
    ],
    computed: {
      ...mapGetters(['items'])
    },
    props: {
      threshold: {
        type: Number,
        default: 1000
      },
      url: String,
      params:{
        type:Object,
        default:{},
      },
      eventName: {
        type: String,
        default: 'clistwrap'
      },
      type: String,
      show: {
        type: Boolean,
        default: true
      },
      cb:{
        type:Object,
        default:defFun
      },
      preHandle:{
        type:Object,
        default:defFun
      },
      funWrap:{
        type:Object,
        default:{}
      }
    },
    events: {},
    methods: {
      ...mapMutations([
        'resetItems',
        'setItems'
      ]),
      intersectionCb(res) {
        const { isLoading, isEnd, threshold } = this;
        res.intersectionRatio; // 相交区域占目标节点的布局区域的比例
        res.intersectionRect; // 相交区域
        res.intersectionRect.left; // 相交区域的左边界坐标
        res.intersectionRect.top; // 相交区域的上边界坐标
        res.intersectionRect.width; // 相交区域的宽度
        res.intersectionRect.height; // 相交区域的高度

        console.log('relativeToViewport', res, res.boundingClientRect.top);
        const canload = res.boundingClientRect.top;

        // this.getRect().then(rect=>{
        console.log('rect', this, this.$slots);
        console.log('recboundingClientRectt', res.boundingClientRect.top);
        // })
        if (!isLoading && !isEnd) {
          this.getData();
        }
      },

      request() {
        const { url, params = {}, pageNum } = this;

        let obj = { ...params, pageNum: pageNum + 1 };
        let _url = urlParams(url, obj);
        console.log('requdser url', _url);
        return get(_url);
      },


      _request() {

        return new Promise((resolve, reject) => {
          let res = {};
          if (this.mockPage == 2 ){
            // this.mockPage += 1;
            reject('error msdsfsd');
            return;
          }
          if (this.mockPage <= this.mockPages) {
            const list = [];
            for (let i = 0; i < 10; i++) {
              const id = `${this.mockPage}-${i}`;
              list.push({
                id,
                'chapter': `chapter${id}`,
                'title': `title${id}`,
                'vfVideoId': `vfVideoId${id}`
              });
            }
            res = {
              'message': 'message',
              'path': 'path',
              'rows': {
                list,
                'pageNum': this.mockPage,
                'pages': this.mockPages,
                'subjectTitle': 'subjectTitle',
                'teacherId': 'teacherId',
                'teacherQualifications': 'teacherQualifications',
                'total': this.mockTotal,
                'totalChaper': 0,
                'upperBody': 'string'
              },
              'status': '200'
            };

            this.mockPage += 1;
          } else {
            res = {
              'message': 'message',
              'path': 'path',
              'rows': {
                'list': [],
                'pageNum': this.mockPage,
                'pages': this.mockPages,
                'subjectTitle': 'subjectTitle',
                'teacherId': 'teacherId',
                'teacherQualifications': 'teacherQualifications',
                'total': this.mockTotal,
                'totalChaper': 0,
                'upperBody': 'string'
              },
              'status': '200'
            };
          }

          setTimeout(()=>{
            resolve(res);

          } , 1000);

        });

      },
      getData() {
        this.isLoading = true;
        const { eventName, url, pageNum, type , cb} = this;
        const items = this.items[type] || [];
        this.request().then(({ rows: { list: res, pageNum, pages, total , ...other}, status, message }) => {
          this.isLoading = false;
          this.loaded = true;

          const s = `${status}`;
          if (status != 200) {
            this.isError = true;
            showMsg(message);
            this.errorMsg = message;
            return;
          }

          // cb(res);

          if(!!res && Array.isArray(res) && res.length > 0){
            const _items = [...items, ...res];
            this.curItems = _items;
            this.setItems({ items: _items, type });
            this.items = _items;
          }

          if (pages == pageNum) {
            this.isEnd = true;
            if (this.ob) {
              this.ob.disconnect();
            }
          }

        }).catch(err => {
          console.log('err', err);
          this.isError = true;
          this.isLoading = false;
        });
      }
    },
    detached() {
      console.log('detached list wrap');
      const { type } = this;
      this.resetItems(type);
    },
    created() {
      console.log('created');
      this.ob = wx.createIntersectionObserver(this.$wx, {
        thresholds: [0]
      });
    },
    attached() {
      console.log('attached');
      const { threshold, type } = this;
      if (!this.ob) {
        this.ob = wx.createIntersectionObserver(this.$wx, {
          thresholds: [0]
        });
      }
      this.ob.relativeToViewport({ bottom: 0 }).observe('.CListWrap-dst', this.intersectionCb.bind(this));

    }
  });
</script>
<style lang="scss">
  clistwrap1 {
    display: block;

  }

  .CListWrap {
    display: block;
  }

  .CListWrap-wrap {

  }

  .CListWrap-wrap-item {
    flex: 1;
  }

  .CListWrap-dst {
    height: 1px;
    background-color: salmon;
    font-size: 30rpx;
    text-align: center;
  }

  .noData{
      text-align: center;
  }


  cloading{
    margin:10rpx;
  }
</style>

<config>
  {
  navigationBarTitleText: '',
  usingComponents: {
  'CLoading':'~UI/CLoading',
  }
  }
</config>
