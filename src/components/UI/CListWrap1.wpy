<template>
  <view class="CListWrap external-cls"
        style="display: {{show ? 'block' : 'none'}}"
  >

    <view class="CListWrap-header">
      <slot name="header"/>
    </view>
    <view class="CListWrap-wrap">

      <slot/>
      <view wx:if="{{curItems.length == 0 && loaded && !isError}}" class="noData">
        没有数据
      </view>
    </view>
    <view class="CListWrap-loading">

    </view>
    <view class="CListWrap-dst">
      <view wx:if="{{isLoading}}">
        <CLoading type="spinner"/>
      </view>
      <view wx:if="{{isEnd && curItems.length > 0}}">
        没有更多了
      </view>
      <view wx:if="{{isError}}">
        {{errorMsg || '加载失败'}}
      </view>
    </view>

  </view>

</template>
<script>
  import wepy from '@wepy/core';
  import store from 'store';
  import { mapMutations, mapGetters } from '@wepy/x';
  import { get } from '@/http/http';
  import { showMsg, urlParams } from '@/common/utils';
  // import {parseRes} from '@/http/http-business';

  const defFun = () => {
    console.log('defFun');
  };
  wepy.component({
    store,
    data: {
      isEnd: false,
      isLoading: false,
      pageNum: 0,
      pages: 0,
      total: 0,
      isError: false,
      errorMsg: '',
      other: {},
      mockPage: 1,
      mockPages: 5,
      mockTotal: 200,
      curItems: [],
      loaded: false
    },
    externalClasses: [
      'external-cls'
    ],
    computed: {
      ...mapGetters(['items'])
    },
    props: {
      threshold: {
        type: Number,
        default: 1000
      },
      url: String,
      params: {
        type: Object,
        default: {}
      },
      eventName: {
        type: String,
        default: 'clistwrap'
      },
      type: String,
      show: {
        type: Boolean,
        default: true
      },
      cb: {
        type: Object,
        default: defFun
      },
      preHandle: {
        type: Object,
        default: defFun
      },
      funWrap: {
        type: Object,
        default: {}
      }
    },
    watch: {
      url(nv, ov) {
        const { type } = this;
        this.resetItems(type);
        this.init(true);

      }
    },
    events: {},
    methods: {
      ...mapMutations([
        'resetItems',
        'setItems'
      ]),
      intersectionCb(res) {
        const { isLoading, isEnd, threshold ,show} = this;
        res.intersectionRatio; // 相交区域占目标节点的布局区域的比例
        res.intersectionRect; // 相交区域
        res.intersectionRect.left; // 相交区域的左边界坐标
        res.intersectionRect.top; // 相交区域的上边界坐标
        res.intersectionRect.width; // 相交区域的宽度
        res.intersectionRect.height; // 相交区域的高度

        console.log('relativeToViewport', res, res.boundingClientRect.top);
        const canload = res.boundingClientRect.top;

        // this.getRect().then(rect=>{
        console.log('rect', this, this.$slots);
        console.log('recboundingClientRectt', res.boundingClientRect.top);
        // })
        if (!isLoading && !isEnd && show) {
          this.getData();
        }
      },

      request() {
        const { url, params = {}, pageNum } = this;

        let obj = { ...params, pageNum: pageNum + 1 };
        let _url = urlParams(url, obj);
        console.log('requdser url', _url);
        return get(_url);
      },

      parseRes(res, errMsg = '请求失败', resolveStatus = [], tipStatus = []) {

        // const c = true;
        // if(typeof beforeCb === 'function'){
        //   c = beforeCb(res);
        // }
        //
        // if(!c){
        //   return;
        // }
        if ((!!res && reg.test(res.status)) || resolveStatus.includes(res.status) || tipStatus.includes(res.status)) {
          if (tipStatus.includes(res.status)) {
            return showMsg(res.message);
          }
          return res;
        } else {
          const msg = res && res.message ? res.message : errMsg;
          // throw new Error(msg ? msg : 'error');
          showMsg(msg);
          return null;
        }
      },
      getData() {
        this.isLoading = true;
        const { eventName, url, pageNum, type, cb } = this;
        const items = this.items[type] || [];
        this.request().then((_res) => {
          const { rows: { list: res, pageNum, pages, total, ...other } = {}, status, message } = _res;
          this.isLoading = false;
          this.loaded = true;

          const s = `${status}`;
          if (status != 200) {
            this.isError = true;
            showMsg(message);
            this.errorMsg = message;
            return;
          }

          // cb(res);

          if (!!res && Array.isArray(res) && res.length > 0) {
            const _items = [...items, ...res];
            this.curItems = _items;
            this.setItems({ items: _items, type });
            this.items = _items;
          }

          if (pages == pageNum) {
            this.isEnd = true;
            if (this.ob) {
              this.ob.disconnect();
            }
          }

        }).catch(err => {
          console.log('err', err);
          this.isError = true;
          this.isLoading = false;
        });
      },
      init(refresh = false) {
        const { threshold, type } = this;


        if(refresh){
          console.log('refresh')
          this.ob = wx.createIntersectionObserver(this.$wx, {
            thresholds: [0]
          });

          this.ob.relativeToViewport({ bottom: 0 }).observe('.CListWrap-dst', this.intersectionCb.bind(this));
        }else{
          // if (!this.ob) {
          //   this.ob = wx.createIntersectionObserver(this.$wx, {
          //     thresholds: [0]
          //   });
          // }
          this.ob.relativeToViewport({ bottom: 0 }).observe('.CListWrap-dst', this.intersectionCb.bind(this));
        }

      }
    },
    detached() {
      console.log('detached list wrap');
      const { type } = this;
      this.resetItems(type);
      if (this.ob) {
        this.ob.disconnect();
      }
    },
    created() {
      console.log('created');
      this.ob = wx.createIntersectionObserver(this.$wx, {
        thresholds: [0]
      });
    },
    attached() {
      this.init();
    }
  });
</script>
<style lang="scss">
  clistwrap1 {
    display: block;
    width: 100%;

  }

  .CListWrap {
    display: block;
  }

  .CListWrap-wrap {

  }

  .CListWrap-wrap-item {
    flex: 1;
  }

  .CListWrap-dst {
    height: 1px;
    background-color: salmon;
    font-size: 30rpx;
    text-align: center;
  }

  .noData {
    text-align: center;
  }


  cloading {
    margin: 10rpx;
  }
</style>

<config>
  {
  navigationBarTitleText: '',
  usingComponents: {
  'CLoading':'~UI/CLoading',
  }
  }
</config>
